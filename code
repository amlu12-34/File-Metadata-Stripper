from __future__ import annotations
import argparse
import os
import shutil
import subprocess
import sys
import tempfile
import zipfile
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple
try:
    from PIL import Image
except Exception:
    Image = None
try:
    import piexif
except Exception:
    piexif = None
try:
    import PyPDF2
except Exception:
    PyPDF2 = None
try:
    from mutagen import File as MutagenFile
    from mutagen.id3 import ID3, ID3NoHeaderError
except Exception:
    MutagenFile = None
@dataclass
class Stats:
    scanned: int = 0
    stripped: int = 0
    skipped: int = 0
    errors: int = 0
def has_exiftool() -> bool:
    try:
        subprocess.run(["exiftool", "-ver"], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except Exception:
        return False
def run_exiftool_strip(path: Path, backup: bool = True, verbose: bool = False) -> Tuple[bool, str]:
    cmd = ["exiftool", "-all=", "-overwrite_original"]
    if not backup:
        cmd = ["exiftool", "-all=", str(path)]
    else:
        cmd = ["exiftool", "-all=", str(path)]
    try:
        if verbose:
            print('RUN:', ' '.join(cmd))
        proc = subprocess.run(cmd, capture_output=True, text=True)
        if proc.returncode == 0:
            if not backup:
                bak = path.with_name(path.name + "_original")
                if bak.exists():
                    bak.unlink()
            return True, proc.stdout.strip()
        else:
            return False, proc.stderr.strip() or proc.stdout.strip()
    except Exception as e:
        return False, str(e)
def strip_jpeg_with_pillow(path: Path, verbose: bool = False) -> bool:
    if Image is None:
        if verbose:
            print("Pillow not available; skipping JPEG fallback for", path)
        return False
    try:
        img = Image.open(path)
        data = list(img.getdata())
        img_without_exif = Image.new(img.mode, img.size)
        img_without_exif.putdata(data)
        img_without_exif.save(path, format=img.format)
        return True
    except Exception as e:
        if verbose:
            print("Error stripping JPEG with Pillow:", e)
        return False
def strip_png_piexif(path: Path, verbose: bool = False) -> bool:
    if Image is None:
        if verbose:
            print("Pillow not available; skipping PNG fallback for", path)
        return False
    try:
        img = Image.open(path)
        img.info.pop('exif', None)
        img.info.pop('timestamp', None)
        tmp = path.with_suffix(path.suffix + ".tmp")
        img.save(tmp, format=img.format)
        tmp.replace(path)
        return True
    except Exception as e:
        if verbose:
            print("Error stripping PNG:", e)
        return False
def strip_pdf_pypdf2(path: Path, verbose: bool = False) -> bool:
    if PyPDF2 is None:
        if verbose:
            print("PyPDF2 not available; skipping PDF fallback for", path)
        return False
    try:
        reader = PyPDF2.PdfReader(str(path))
        writer = PyPDF2.PdfWriter()
        for page in reader.pages:
            writer.add_page(page)
        writer.add_metadata({})
        tmp = path.with_suffix(path.suffix + '.tmp')
        with open(tmp, 'wb') as f:
            writer.write(f)
        tmp.replace(path)
        return True
    except Exception as e:
        if verbose:
            print('Error stripping PDF:', e)
        return False
def strip_docx_coreprops(path: Path, verbose: bool = False) -> bool:
    try:
        with zipfile.ZipFile(path, 'r') as zin:
            names = zin.namelist()
            if 'docProps/core.xml' not in names:
                return True
            core = zin.read('docProps/core.xml')
        ET.register_namespace('cp', 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties')
        ET.register_namespace('dc', 'http://purl.org/dc/elements/1.1/')
        root = ET.fromstring(core)
        for child in list(root):
            child.text = ''
        tmp = tempfile.NamedTemporaryFile(delete=False)
        try:
            with zipfile.ZipFile(path, 'r') as zin, zipfile.ZipFile(tmp.name, 'w') as zout:
                for item in zin.infolist():
                    if item.filename == 'docProps/core.xml':
                        zout.writestr(item, ET.tostring(root, encoding='utf-8'))
                    else:
                        zout.writestr(item, zin.read(item.filename))
            shutil.move(tmp.name, str(path))
            return True
        finally:
            try:
                os.unlink(tmp.name)
            except Exception:
                pass
    except Exception as e:
        if verbose:
            print('Error stripping DOCX core properties:', e)
        return False
def strip_mp3_mutagen(path: Path, verbose: bool = False) -> bool:
    if MutagenFile is None:
        if verbose:
            print('Mutagen not available; skipping MP3 fallback for', path)
        return False
    try:
        audio = MutagenFile(str(path), easy=True)
        if audio is None:
            return False
        audio.delete()
        audio.save()
        return True
    except Exception as e:
        if verbose:
            print('Error stripping MP3 tags:', e)
        return False
def make_backup(path: Path) -> Path:
    bak = path.with_suffix(path.suffix + '.bak')
    shutil.copy2(path, bak)
    return bak
def process_file(path: Path, stats: Stats, args) -> None:
    stats.scanned += 1
    p = path
    if args.verbose:
        print('\n[+] Processing', p)
    used_exiftool = False
    success = False
    report = ''
    if args.exiftool_available:
        ok, msg = run_exiftool_strip(p, backup=args.backup, verbose=args.verbose)
        used_exiftool = True
        success = ok
        report = msg
    else:
        ext = p.suffix.lower()
        if ext in ('.jpg', '.jpeg'):
            if args.backup:
                make_backup(p)
            success = strip_jpeg_with_pillow(p, verbose=args.verbose)
        elif ext == '.png':
            if args.backup:
                make_backup(p)
            success = strip_png_piexif(p, verbose=args.verbose)
        elif ext == '.pdf':
            if args.backup:
                make_backup(p)
            success = strip_pdf_pypdf2(p, verbose=args.verbose)
        elif ext == '.docx':
            if args.backup:
                make_backup(p)
            success = strip_docx_coreprops(p, verbose=args.verbose)
        elif ext == '.mp3':
            if args.backup:
                make_backup(p)
            success = strip_mp3_mutagen(p, verbose=args.verbose)
        else:
            if args.verbose:
                print('No fallback implemented for', ext, '- consider installing exiftool for best coverage')
            success = False
    if success:
        stats.stripped += 1
        if args.verbose:
            if used_exiftool:
                print('exiftool: OK', report)
            else:
                print('stripped using python fallback')
    else:
        stats.skipped += 1
        if args.verbose:
            print('skipped or failed to strip metadata for', p)
def gather_files(targets: List[Path], recursive: bool, patterns: List[str]) -> List[Path]:
    out: List[Path] = []
    for t in targets:
        if t.is_dir():
            if recursive:
                for root, _, files in os.walk(t):
                    for fn in files:
                        p = Path(root) / fn
                        if not patterns or any(p.match(pat) for pat in patterns):
                            out.append(p)
            else:
                for fn in os.listdir(t):
                    p = t / fn
                    if p.is_file() and (not patterns or any(p.match(pat) for pat in patterns)):
                        out.append(p)
        elif t.is_file():
            out.append(t)
    return out
def parse_args():
    ap = argparse.ArgumentParser(description='File Metadata Stripper â€” Privacy & Security')
    ap.add_argument('targets', nargs='+', help='Files or directories to process(add file or folder path)')
    ap.add_argument('-r', '--recursive', action='store_true', help='Recurse into directories')
    ap.add_argument('-n', '--dry-run', action='store_true', help="Show what would be done but don't modify files")
    ap.add_argument('-b', '--backup', action='store_true', help='Create .bak backups before modifying')
    ap.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    ap.add_argument('-p', '--pattern', action='append', help='Glob pattern to filter files (can be used multiple times)')
    return ap.parse_args()
def main():
    args = parse_args()
    targets = [Path(t) for t in args.targets]
    files = gather_files(targets, args.recursive, args.pattern or [])
    args.exiftool_available = has_exiftool()
    if args.verbose:
        print('exiftool available?', args.exiftool_available)
        print('Found', len(files), 'files to consider')
    stats = Stats()
    if args.dry_run:
        print('DRY RUN: no files will be modified')
    for f in files:
        try:
            if args.dry_run:
                print('[DRY] Would process', f)
                stats.scanned += 1
                continue
            process_file(f, stats, args)
        except Exception as e:
            stats.errors += 1
            if args.verbose:
                print('Error processing', f, e)
    print('\nSummary:')
    print(' Scanned:', stats.scanned)
    print(' Stripped:', stats.stripped)
    print(' Skipped/Failed:', stats.skipped)
    print(' Errors:', stats.errors)
if __name__ == '__main__':
    main()
